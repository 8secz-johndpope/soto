//===----------------------------------------------------------------------===//
//
// This source file is part of the AWSSDKSwift open source project
//
// Copyright (c) 2017-2020 the AWSSDKSwift project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of AWSSDKSwift project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/swift-aws/aws-sdk-swift/blob/main/CodeGenerator/Sources/CodeGenerator/main.swift. DO NOT EDIT.

@_exported import AWSSDKSwiftCore

/*
Client object for interacting with AWS SMS service.

AWS Server Migration Service AWS Server Migration Service (AWS SMS) makes it easier and faster for you to migrate your on-premises workloads to AWS. To learn more about AWS SMS, see the following resources:    AWS Server Migration Service product page     AWS Server Migration Service User Guide   
*/
public struct SMS: AWSService {

    // MARK: Member variables

    public let client: AWSClient
    public let config: AWSServiceConfig
    public let context: AWSServiceContext

    // MARK: Initialization

    /// Initialize the SMS client
    /// - parameters:
    ///     - client: AWSClient used to process requests
    ///     - region: Region of server you want to communicate with. This will override the partition parameter.
    ///     - partition: AWS partition where service resides, standard (.aws), china (.awscn), government (.awsusgov).
    ///     - endpoint: Custom endpoint URL to use instead of standard AWS servers
    ///     - timeout: Timeout value for HTTP requests
    public init(
        client: AWSClient,
        region: AWSSDKSwiftCore.Region? = nil,
        partition: AWSPartition = .aws,
        endpoint: String? = nil,
        timeout: TimeAmount? = nil
    ) {
        self.client = client
        self.config = AWSServiceConfig(
            region: region,
            partition: region?.partition ?? partition,
            amzTarget: "AWSServerMigrationService_V2016_10_24",
            service: "sms",
            serviceProtocol: .json(version: "1.1"),
            apiVersion: "2016-10-24",
            endpoint: endpoint,
            possibleErrorTypes: [SMSErrorType.self]        )
        self.context = .init(timeout: timeout ?? .seconds(20))
    }

    /// create copy of service with new context
    public func withNewContext(_ process: (AWSServiceContext) -> AWSServiceContext) -> Self {
        return Self(client: self.client, config: self.config, context: process(self.context))
    }

    // MARK: API Calls

    ///  Creates an application. An application consists of one or more server groups. Each server group contain one or more servers.
    public func createApp(_ input: CreateAppRequest) -> EventLoopFuture<CreateAppResponse> {
        return client.execute(operation: "CreateApp", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates a replication job. The replication job schedules periodic replication runs to replicate your server to AWS. Each replication run creates an Amazon Machine Image (AMI).
    public func createReplicationJob(_ input: CreateReplicationJobRequest) -> EventLoopFuture<CreateReplicationJobResponse> {
        return client.execute(operation: "CreateReplicationJob", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes the specified application. Optionally deletes the launched stack associated with the application and all AWS SMS replication jobs for servers in the application.
    public func deleteApp(_ input: DeleteAppRequest) -> EventLoopFuture<DeleteAppResponse> {
        return client.execute(operation: "DeleteApp", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes the launch configuration for the specified application.
    public func deleteAppLaunchConfiguration(_ input: DeleteAppLaunchConfigurationRequest) -> EventLoopFuture<DeleteAppLaunchConfigurationResponse> {
        return client.execute(operation: "DeleteAppLaunchConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes the replication configuration for the specified application.
    public func deleteAppReplicationConfiguration(_ input: DeleteAppReplicationConfigurationRequest) -> EventLoopFuture<DeleteAppReplicationConfigurationResponse> {
        return client.execute(operation: "DeleteAppReplicationConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes the validation configuration for the specified application.
    public func deleteAppValidationConfiguration(_ input: DeleteAppValidationConfigurationRequest) -> EventLoopFuture<DeleteAppValidationConfigurationResponse> {
        return client.execute(operation: "DeleteAppValidationConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes the specified replication job. After you delete a replication job, there are no further replication runs. AWS deletes the contents of the Amazon S3 bucket used to store AWS SMS artifacts. The AMIs created by the replication runs are not deleted.
    public func deleteReplicationJob(_ input: DeleteReplicationJobRequest) -> EventLoopFuture<DeleteReplicationJobResponse> {
        return client.execute(operation: "DeleteReplicationJob", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Deletes all servers from your server catalog.
    public func deleteServerCatalog(_ input: DeleteServerCatalogRequest) -> EventLoopFuture<DeleteServerCatalogResponse> {
        return client.execute(operation: "DeleteServerCatalog", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Disassociates the specified connector from AWS SMS. After you disassociate a connector, it is no longer available to support replication jobs.
    public func disassociateConnector(_ input: DisassociateConnectorRequest) -> EventLoopFuture<DisassociateConnectorResponse> {
        return client.execute(operation: "DisassociateConnector", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Generates a target change set for a currently launched stack and writes it to an Amazon S3 object in the customer’s Amazon S3 bucket.
    public func generateChangeSet(_ input: GenerateChangeSetRequest) -> EventLoopFuture<GenerateChangeSetResponse> {
        return client.execute(operation: "GenerateChangeSet", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Generates an AWS CloudFormation template based on the current launch configuration and writes it to an Amazon S3 object in the customer’s Amazon S3 bucket.
    public func generateTemplate(_ input: GenerateTemplateRequest) -> EventLoopFuture<GenerateTemplateResponse> {
        return client.execute(operation: "GenerateTemplate", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Retrieve information about the specified application.
    public func getApp(_ input: GetAppRequest) -> EventLoopFuture<GetAppResponse> {
        return client.execute(operation: "GetApp", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Retrieves the application launch configuration associated with the specified application.
    public func getAppLaunchConfiguration(_ input: GetAppLaunchConfigurationRequest) -> EventLoopFuture<GetAppLaunchConfigurationResponse> {
        return client.execute(operation: "GetAppLaunchConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Retrieves the application replication configuration associated with the specified application.
    public func getAppReplicationConfiguration(_ input: GetAppReplicationConfigurationRequest) -> EventLoopFuture<GetAppReplicationConfigurationResponse> {
        return client.execute(operation: "GetAppReplicationConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Retrieves information about a configuration for validating an application.
    public func getAppValidationConfiguration(_ input: GetAppValidationConfigurationRequest) -> EventLoopFuture<GetAppValidationConfigurationResponse> {
        return client.execute(operation: "GetAppValidationConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Retrieves output from validating an application.
    public func getAppValidationOutput(_ input: GetAppValidationOutputRequest) -> EventLoopFuture<GetAppValidationOutputResponse> {
        return client.execute(operation: "GetAppValidationOutput", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes the connectors registered with the AWS SMS.
    public func getConnectors(_ input: GetConnectorsRequest) -> EventLoopFuture<GetConnectorsResponse> {
        return client.execute(operation: "GetConnectors", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes the specified replication job or all of your replication jobs.
    public func getReplicationJobs(_ input: GetReplicationJobsRequest) -> EventLoopFuture<GetReplicationJobsResponse> {
        return client.execute(operation: "GetReplicationJobs", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes the replication runs for the specified replication job.
    public func getReplicationRuns(_ input: GetReplicationRunsRequest) -> EventLoopFuture<GetReplicationRunsResponse> {
        return client.execute(operation: "GetReplicationRuns", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Describes the servers in your server catalog. Before you can describe your servers, you must import them using ImportServerCatalog.
    public func getServers(_ input: GetServersRequest) -> EventLoopFuture<GetServersResponse> {
        return client.execute(operation: "GetServers", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Allows application import from AWS Migration Hub.
    public func importAppCatalog(_ input: ImportAppCatalogRequest) -> EventLoopFuture<ImportAppCatalogResponse> {
        return client.execute(operation: "ImportAppCatalog", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Gathers a complete list of on-premises servers. Connectors must be installed and monitoring all servers to import. This call returns immediately, but might take additional time to retrieve all the servers.
    public func importServerCatalog(_ input: ImportServerCatalogRequest) -> EventLoopFuture<ImportServerCatalogResponse> {
        return client.execute(operation: "ImportServerCatalog", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Launches the specified application as a stack in AWS CloudFormation.
    public func launchApp(_ input: LaunchAppRequest) -> EventLoopFuture<LaunchAppResponse> {
        return client.execute(operation: "LaunchApp", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Retrieves summaries for all applications.
    public func listApps(_ input: ListAppsRequest) -> EventLoopFuture<ListAppsResponse> {
        return client.execute(operation: "ListApps", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Provides information to AWS SMS about whether application validation is successful.
    public func notifyAppValidationOutput(_ input: NotifyAppValidationOutputRequest) -> EventLoopFuture<NotifyAppValidationOutputResponse> {
        return client.execute(operation: "NotifyAppValidationOutput", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates or updates the launch configuration for the specified application.
    public func putAppLaunchConfiguration(_ input: PutAppLaunchConfigurationRequest) -> EventLoopFuture<PutAppLaunchConfigurationResponse> {
        return client.execute(operation: "PutAppLaunchConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates or updates the replication configuration for the specified application.
    public func putAppReplicationConfiguration(_ input: PutAppReplicationConfigurationRequest) -> EventLoopFuture<PutAppReplicationConfigurationResponse> {
        return client.execute(operation: "PutAppReplicationConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Creates or updates a validation configuration for the specified application.
    public func putAppValidationConfiguration(_ input: PutAppValidationConfigurationRequest) -> EventLoopFuture<PutAppValidationConfigurationResponse> {
        return client.execute(operation: "PutAppValidationConfiguration", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Starts replicating the specified application by creating replication jobs for each server in the application.
    public func startAppReplication(_ input: StartAppReplicationRequest) -> EventLoopFuture<StartAppReplicationResponse> {
        return client.execute(operation: "StartAppReplication", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Starts an on-demand replication run for the specified application.
    public func startOnDemandAppReplication(_ input: StartOnDemandAppReplicationRequest) -> EventLoopFuture<StartOnDemandAppReplicationResponse> {
        return client.execute(operation: "StartOnDemandAppReplication", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Starts an on-demand replication run for the specified replication job. This replication run starts immediately. This replication run is in addition to the ones already scheduled. There is a limit on the number of on-demand replications runs that you can request in a 24-hour period.
    public func startOnDemandReplicationRun(_ input: StartOnDemandReplicationRunRequest) -> EventLoopFuture<StartOnDemandReplicationRunResponse> {
        return client.execute(operation: "StartOnDemandReplicationRun", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Stops replicating the specified application by deleting the replication job for each server in the application.
    public func stopAppReplication(_ input: StopAppReplicationRequest) -> EventLoopFuture<StopAppReplicationResponse> {
        return client.execute(operation: "StopAppReplication", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Terminates the stack for the specified application.
    public func terminateApp(_ input: TerminateAppRequest) -> EventLoopFuture<TerminateAppResponse> {
        return client.execute(operation: "TerminateApp", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Updates the specified application.
    public func updateApp(_ input: UpdateAppRequest) -> EventLoopFuture<UpdateAppResponse> {
        return client.execute(operation: "UpdateApp", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }

    ///  Updates the specified settings for the specified replication job.
    public func updateReplicationJob(_ input: UpdateReplicationJobRequest) -> EventLoopFuture<UpdateReplicationJobResponse> {
        return client.execute(operation: "UpdateReplicationJob", path: "/", httpMethod: .POST, input: input, config: self.config, context: self.context)
    }
}

extension SMS {
    /// internal initialiser used by `withNewContext`
    init(client: AWSClient, config: AWSServiceConfig, context: AWSServiceContext) {
        self.client = client
        self.config = config
        self.context = context
    }
}
